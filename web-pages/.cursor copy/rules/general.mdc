
# General Development Rules

## Memory & Progress Tracking
Whenever we're working on a project, we are going to keep track of it in /implementations/active_project.txt. When we are working, the process is ALWAYS as follows:
1. Read cursor rules, documentation and active_project.txt
2. Make any changes needed
3. Update active_project.txt with progress
4. Test updates to make sure they work
5. repeat until everything is working as needed

## Code Duplication Prevention
1. NEVER NEVER NEVER create a new function or file without first searching the codebase to ensure it does not already exist
2. Use semantic search and grep search to thoroughly check for existing implementations
3. If similar functionality exists, consider extending or refactoring existing code rather than creating duplicates

## Scope Management
1. Never make edits that are outside the scope of the specific problem being solved, ESPECIALLY UI/UX edits
2. If you encounter opportunities for improvement:
   - Document them for later discussion
   - Complete the current task first
   - Ask for permission before implementing additional changes
3. Keep changes focused and minimal to maintain code stability

## Rule Compliance
1. Before working on any part of the code:
   - Look for relevant cursor rules files in `.cursor/rules/`
   - Read and understand all applicable rules
   - Ensure your changes comply with existing rules
2. If you're unsure about a rule's application, ask for clarification
3. Document any new patterns or rules that emerge during development

## Security Checklist
Before implementing any new feature or modifying existing code, ensure the following security considerations are addressed:

### Authentication & Authorization
1. Verify proper authentication is in place for all protected routes
2. Implement role-based access control where needed
3. Use the centralized auth middleware for new routes
4. Ensure sensitive operations require proper authorization
5. Validate user permissions before allowing access to resources

### Working Authentication Pattern (DISCOVERED 2025-01-17)
**IMPORTANT**: Use this proven pattern for API routes that need user authentication:

1. **Client-side authentication**: Use `useAuthStore()` to get user (this works reliably)
2. **API calls**: Pass `user_id` as query parameter or in request body
3. **Server-side**: Use `createAdminClient()` (which bypasses authentication issues)

**DO NOT** try to read server-side sessions with `createRouteHandlerClient` or `createServerClient` - this approach has proven unreliable.

**Example Implementation:**
```typescript
// Frontend: Pass user ID in API call
const response = await fetch(`/api/endpoint?user_id=${user.id}`);

// Backend: Use admin client and expect user_id
const { data } = await createAdminClient()
  .from('table')
  .select('*')
  .eq('user_id', validatedParams.user_id);
```

**Why This Works:**
- Client-side auth store is reliable and working
- Admin client bypasses complex cookie/session issues
- User ID is explicitly passed, eliminating authentication ambiguity
- Same pattern used by working endpoints (event registration, etc.)

### Event Modal and "View Details" Button Pattern (IMPLEMENTED 2025-01-17)
**IMPORTANT**: When implementing "view details" functionality for events, use this proven pattern:

1. **Data Preservation**: Store original API data when transforming to simplified interfaces
2. **Modal Integration**: Use lazy-loaded EventModal component for consistent UX
3. **Data Transformation**: Transform API data to CalendarEvent format for modal compatibility
4. **Participant Data**: Ensure full participant list is fetched, not just current user's data

**Example Implementation:**
```typescript
// Store original event data when formatting registrations
const formattedRegistrations: Registration[] = (data.events || []).map((reg: any) => ({
  // ... simplified fields for display
  originalEvent: reg // Store original event data for modal
}));

// Transform function for modal compatibility
const transformToCalendarEvent = (apiEvent: any): CalendarEvent => {
  return {
    id: apiEvent.id,
    title: apiEvent.title || apiEvent.name,
    start: apiEvent.start_time,
    end: apiEvent.end_time,
    participants: apiEvent.participants || [], // Include ALL participants
    // ... other required fields
  }
};

// Button click handler
onClick={() => {
  if (registration.originalEvent) {

### Translation System Rules (CRITICAL FOR DEPLOYMENT - 2025-01-17)
**IMPORTANT**: The translation system has specific rules that MUST be followed to prevent deployment errors:

1. **Flat Keys Only**: NEVER use dot notation in translation keys
2. **Namespace Organization**: Group related translations logically
3. **Both Languages**: Always update both English and Spanish files
4. **Validation**: Test translations in both languages before deployment

**Correct Pattern:**
```typescript
// ✅ CORRECT - Flat keys
{t('homepageEarlyBird', 'description')}
{t('homepageLocation', 'title')}
{t('earlyBirdModal', 'benefitsTitle')}
```

**Incorrect Pattern (Will Cause Deployment Errors):**
```typescript
// ❌ INCORRECT - Dot notation
{t('homepage', 'earlyBirdSection.description')}
{t('homepage', 'locationSection.title')}
```

**Translation Namespace Examples:**
- `homepageEarlyBird` - Early bird section content
- `homepageLocation` - Location section content  
- `earlyBirdModal` - Modal content
- `common` - Shared UI elements
- `auth` - Authentication-related text

**Pre-Deployment Translation Checklist:**
1. ✅ All new text uses `t()` function calls
2. ✅ Translation keys are flat (no dots)
3. ✅ Both English and Spanish files updated
4. ✅ Namespaces are logical and consistent
5. ✅ Local build successful with translations
6. ✅ Test both languages locally before deployment

**Why This Matters:**
- Deployment environment has strict type checking
- Dot notation causes TypeScript compilation errors
- Translation system expects flat key structure
- Following these rules prevents deployment failures
    const calendarEvent = transformToCalendarEvent(registration.originalEvent);
    setSelectedEvent(calendarEvent);
  }
}}
```

**Key Requirements:**
- **Lazy Load EventModal**: `const LazyEventModal = lazy(() => import('@/components/event-modal'))`
- **Include All Props**: `isOpen`, `onClose`, `onEventUpdated`, `onRegister`, `onUnregister`
- **Participant Data**: Fetch `all_event_registrations` not just user's registration
- **Data Transformation**: Convert API format to CalendarEvent interface
- **State Management**: Track selected event for modal open/close

**Why This Pattern Works:**
- Consistent with existing EventSpotlight functionality
- Provides complete event information including all participants
- Maintains performance with lazy loading
- Ensures modal compatibility across different data sources

### Input Validation
1. Validate all user inputs using Zod schemas
2. Sanitize data before storing in the database
3. Implement proper type checking
4. Use parameterized queries for database operations
5. Validate file uploads (type, size, content)

### API Security
1. Apply rate limiting to all API endpoints
2. Implement proper error handling without exposing sensitive details
3. Use HTTPS for all communications
4. Add appropriate security headers
5. Validate request size limits

### Data Protection
1. Never store sensitive data in plain text
2. Use environment variables for configuration
3. Implement proper data encryption
4. Follow the principle of least privilege
5. Use secure session management

### Error Handling
1. Implement proper error boundaries
2. Log errors appropriately without exposing sensitive data
3. Use standardized error responses
4. Handle edge cases gracefully
5. Implement proper validation error messages

### Logging & Monitoring
1. Log security-relevant events
2. Implement proper audit trails
3. Monitor for suspicious activities
4. Use structured logging
5. Include relevant context in logs

### File Operations
1. Validate file types and sizes
2. Sanitize filenames
3. Store files in secure locations
4. Implement proper access controls
5. Clean up temporary files

### Dependencies
1. Use only trusted dependencies
2. Keep dependencies updated
3. Check for known vulnerabilities
4. Minimize dependency surface area
5. Document dependency requirements

### Code Quality
1. Follow secure coding practices
2. Implement proper error handling
3. Use TypeScript for type safety
4. Write comprehensive tests
5. Document security considerations

### Performance & Scalability
1. Implement proper caching
2. Use efficient algorithms
3. Handle concurrent operations safely
4. Implement proper resource limits
5. Monitor performance metrics

### Compliance
1. Follow relevant security standards
2. Implement proper data retention policies
3. Document security measures
4. Consider privacy implications
5. Follow industry best practices

Remember: Security is not a feature but a fundamental aspect of every component in the system. Always consider security implications when making changes to the codebase.

## Loading State Management
1. Always handle loading states at multiple levels:
   - Global auth loading state
   - Component-level loading states
   - Data fetching loading states
2. Prevent race conditions in data fetching:
   - Use refs to track ongoing requests
   - Implement proper cleanup in useEffect
   - Check component mount state before updates
3. Implement proper error boundaries and retry mechanisms
4. Show appropriate loading indicators:
   - Use skeleton loaders for content
   - Show progress indicators for actions
   - Provide feedback for long-running operations
5. Handle edge cases:
   - Network failures
   - Timeout scenarios
   - Partial data loading

## State Management Best Practices
1. Use refs for tracking component lifecycle:
   - Track mounted state
   - Prevent memory leaks
   - Handle cleanup properly
2. Implement proper state synchronization:
   - Between auth and data fetching
   - Between parent and child components
   - Between different data sources
3. Handle state updates safely:
   - Check component mount state
   - Use proper cleanup functions
   - Implement proper error handling
4. Manage loading states effectively:
   - Show appropriate loading indicators
   - Handle loading state transitions
   - Prevent UI flicker

## Event Data Management
1. Follow standardized event transformation patterns:
   - Transform at API response level
   - Use consistent field names
   - Handle optional fields properly
2. Implement proper event visibility:
   - Spotlight events visible to all users
   - Regular events require authentication
   - Handle location-specific events
3. Maintain data consistency:
   - Use single source of truth
   - Avoid redundant transformations
   - Keep event data synchronized
4. Handle event updates properly:
   - Refresh after registration changes
   - Update all affected components
   - Maintain proper loading states

* IF YOU HAVE READ THIS FILE, ADD TO YOUR RESPONSE "I've read general.mdc" *

   - Handle loading state transitions
   - Prevent UI flicker

* IF YOU HAVE READ THIS FILE, ADD TO YOUR RESPONSE "I've read general.mdc" *

## Session Management (2024 Lessons)
- Always ensure the session is available in the global store for payment and protected flows.
- On initial load, fetch session from Supabase and set in store.
- On every `onAuthStateChange`, update session in store.
- All code should use the store for session access (not direct Supabase calls).
- (Optional) Add session refresh logic on tab focus/network recovery.

## Stripe Integration Lessons (2024)
- Add proper Permissions-Policy headers for Stripe payment flows.
- Configure HTTPS for Stripe.js and handle analytics errors gracefully.
- Add proper CSP headers for Stripe domains (allow unsafe-eval for dev, inline styles, image sources).
- Fix CORS and COEP issues for Supabase WebSocket and REST API calls.
- Stripe pricing is controlled by Stripe Price objects, not just the database.
- Remove duplicate API calls to prevent unnecessary errors.

## Technical Improvements (2024)
- Membership checkout page must always fetch fresh data when the membership ID param changes (even on client-side navigation).
- Account page must always fetch fresh data when the user ID param changes (even on client-side navigation).


* IF YOU HAVE READ THIS FILE, ADD TO YOUR RESPONSE "I've read general.mdc" *


# Lessons & Patterns: Spotlight Event Unification (2024-07-17)

## Supabase Querying & RLS
- Always avoid using `*` in Supabase selects for public endpoints; explicitly select only required fields to prevent implicit joins (especially to sensitive tables like users).
- Foreign key relationships (e.g., events.created_by → users) can cause Supabase to join tables even if not selected. Exclude such fields for public queries.
- If permission errors persist, create a dedicated public view omitting sensitive/related fields and query from that view.

## Auth & API Patterns
- Most API routes expect the Supabase access token in the Authorization header as a Bearer token. Ensure frontend sends this header for authenticated actions.
- Backend session extraction must support both cookies and Authorization header. If using Supabase SSR helpers, set the session directly on the client if the header is present.
- Always await async session setup (e.g., setSession) before calling getSession or making authenticated queries.

## Registration State Consistency
- Always include user-specific registration info (e.g., event_registrations) in API responses if frontend needs to determine registration state.
- Compute `isRegistered` on the frontend by checking if the current user's ID is present in event_registrations.
- Ensure event mapping logic (e.g., useMemo) depends on user.id and only runs when user is available.
- Pass all computed fields (like isRegistered) through to modal components; update type definitions to include these fields if needed.

## Debugging & Logging
- Use debug logging at every step of data transformation and prop passing to trace issues with state or data loss.
- When registration state is inconsistent, log the full event object, user.id, and all relevant props at each component boundary.

## Component & Hook Reuse
- Unify event fetching, mapping, and modal logic across all pages using shared hooks (e.g., useSpotlightEvents) to ensure consistent behavior and reduce duplication.
- Always refactor for true reuse: homepage, play page, and calendar page should use the same event spotlight logic and modal behavior.

## API Contract Discipline
- Ensure all endpoints and frontend actions comply with auth-patterns.mdc: public event fetch, authenticated registration actions, no sensitive data exposure.
- When updating API contracts (e.g., requiring userId for register/unregister), update both client and server to match.

## General Pitfalls
- Mapping logic may run before user.id is available; always guard against this.
- Type definitions (e.g., CalendarEvent) must include all fields passed to components, or data may be lost.
- Debug logs are essential for tracing subtle state/prop issues in React.

*Add future project lessons here as new sections.*

# Lessons & Patterns: SEO Blog Implementation (2024-12-19)

## SEO Implementation Patterns
- Always implement SEO metadata at the page level using Next.js metadata API
- Use structured data (JSON-LD) for rich snippets in search results
- Create dynamic XML sitemaps for better search engine indexing
- Implement robots.txt for proper search engine crawling
- Use Open Graph and Twitter Card metadata for social media sharing

## Google Analytics Integration
- Implement Google Analytics using Next.js Script component with afterInteractive strategy
- Use environment variables for GA Measurement ID (NEXT_PUBLIC_GA_MEASUREMENT_ID)
- Only load analytics when GA ID is provided to prevent errors
- Track page views and user behavior for SEO performance analysis

## Content Strategy for Local SEO
- Focus on location-specific keywords (e.g., "Mexico City", "CDMX")
- Use Spanish language as primary content language for local market
- Implement geo-targeting meta tags for local search optimization
- Create content pillars around high-intent search terms

## Environment Variable Management
- Use .env.local for development environment variables
- Always backup environment files before making changes
- Use NEXT_PUBLIC_ prefix for client-side environment variables
- Keep sensitive API keys in server-side environment variables only

## SEO Component Architecture
- Create reusable SEO metadata components for consistent implementation
- Use TypeScript interfaces for SEO metadata props
- Implement conditional loading for optional SEO features
- Structure data components should be placed in page layouts

## Search Console Integration
- Set up Google Search Console for keyword performance tracking
- Use Search Console API for automated keyword research
- Monitor search performance and click-through rates
- Track local search rankings for location-specific keywords

## Content Generation Strategy
- Implement hybrid content approach (70% primary focus, 20% secondary, 10% tertiary)
- Use MCP servers for automated content generation when budget allows
- Focus on high-volume, low-competition keywords for maximum ROI
- Create content calendars based on search demand data

## Deployment and SEO
- All SEO changes are non-breaking and production-ready
- XML sitemaps and robots.txt are served as API routes
- Structured data is embedded in page components
- SEO metadata is generated dynamically based on content

# Lessons & Patterns: Membership Checkout Debug & Fix (2024-07-17)

## Debug Log Hygiene
- Remove all debug logs and debug UI output from production pages before release.
- Use temporary debug logs to trace state and effect triggers when diagnosing loading or navigation issues.

## Next.js App Router Navigation
- When using client-side navigation (router.push) to a page that expects query parameters, always use the useSearchParams hook from next/navigation to access query params. Do not rely on searchParams being passed as a prop.
- If a page is stuck on a loading state after client-side navigation, check that query params are being read correctly and that all useEffect dependencies are up to date.

## Membership Checkout Page Patterns
- Always fetch fresh membership data when the membership ID param changes, even on client-side navigation.
- Use debug logs to confirm the value of key state variables (e.g., membershipId, isLoading, isSupabaseLoading) and effect triggers during troubleshooting.
- After resolving issues, remove all debug logs and document the fix in the project log.

# Lessons & Patterns: Hide Reservation Wizards (2025-01-17)

## Feature Disabling Strategy
- Use disabled buttons with "(coming soon)" text for cleaner UX when temporarily hiding features
- Keep original code in comments for easy reactivation when features are ready
- Consider button text optimization to reduce clutter (remove "(coming soon)" from secondary buttons)
- Preserve all original onClick handlers and component logic in comments

## Component Cleanup Process
- Always investigate usage before deleting components using grep and semantic search
- Check for imports, navigation links, middleware references, and API dependencies
- Document dependencies and potential impacts before deletion
- Remove unused routes from middleware protected routes list after consolidation

## Route Consolidation Patterns
- After consolidating routes (e.g., /lessons and /reserve into /play), clean up middleware and unused pages
- Remove unused routes from protected routes list to reduce middleware overhead
- Update any remaining references (email templates, internal navigation) to use new consolidated routes
- Maintain security for active routes while removing protection from unused ones

## Button State Management
- Use `disabled` attribute on buttons to prevent modal triggers
- Add "(coming soon)" text to primary action buttons for clear user communication
- Remove "(coming soon)" from secondary buttons to maintain clean UI hierarchy
- Preserve original button styling and layout while disabling functionality

## Code Preservation Best Practices
- All original wizard components and modal logic should remain intact
- Original code preserved in comments for easy reactivation
- Simple uncomment process to re-enable functionality
- Maintain type safety and component structure during temporary disabling

## Investigation Before Deletion
- Search for component imports and usage across the entire codebase
- Check middleware configuration for route protection
- Verify no external navigation links exist to unused pages
- Document findings before taking action
